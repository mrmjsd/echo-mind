name: CI/CD - EchoMind

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  lint-and-test:
    name: Lint & Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install backend dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.backend.txt ]; then pip install -r requirements.backend.txt; fi

      - name: Install frontend dependencies
        run: |
          if [ -f requirements.frontend.txt ]; then pip install -r requirements.frontend.txt; fi

      - name: Run tests (placeholder)
        run: |
          echo "Add pytest/streamlit e2e tests here."

  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    needs: lint-and-test
    if: github.ref == 'refs/heads/main'
    env:
      LISTENER_PORT: 2222

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4


      - name: Install cloudflared
        run: |
          sudo apt-get update
          sudo apt-get install -y wget
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared-linux-amd64.deb

      - name: Add known hosts
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_PORT: ${{ secrets.SSH_PORT }}
          SSH_KNOWN_HOST: ${{ secrets.SSH_KNOWN_HOST }}
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          KNOWN_HOSTS_FILE="$HOME/.ssh/known_hosts"
          touch "$KNOWN_HOSTS_FILE"

          if [ -n "$SSH_KNOWN_HOST" ]; then
            printf "%s\n" "$SSH_KNOWN_HOST" >> "$KNOWN_HOSTS_FILE"
          else
            ssh-keyscan -p "$SSH_PORT" "$SSH_HOST" >> "$KNOWN_HOSTS_FILE"
          fi

      - name: Configure SSH key
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          if [ -z "$SSH_PRIVATE_KEY" ]; then
            echo "SSH_PRIVATE_KEY secret is not set."
            exit 1
          fi

          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519

      - name: Deploy via Cloudflare Tunnel SSH
        env:
          CF_ACCESS_HOSTNAME: ${{ secrets.CF_ACCESS_HOSTNAME }}
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USER: ${{ secrets.SSH_USER }}
          SSH_PORT: ${{ secrets.SSH_PORT }}
          APP_DIR: ${{ secrets.APP_DIR }}
          CF_ACCESS_SERVICE_TOKEN_ID: ${{ secrets.CF_ACCESS_SERVICE_TOKEN_ID }}
          CF_ACCESS_SERVICE_TOKEN_SECRET: ${{ secrets.CF_ACCESS_SERVICE_TOKEN_SECRET }}
          ROOT_ENV_B64: ${{ secrets.ROOT_ENV_B64 }}
          UI_ENV_B64: ${{ secrets.UI_ENV_B64 }}
          REPO_URL: https://github.com/${{ github.repository }}.git
        run: |
          set -euo pipefail

          echo "Starting Cloudflare Access TCP listener on port ${LISTENER_PORT}..."
          cloudflared access tcp \
            --hostname "$CF_ACCESS_HOSTNAME" \
            --service-token-id "$CF_ACCESS_SERVICE_TOKEN_ID" \
            --service-token-secret "$CF_ACCESS_SERVICE_TOKEN_SECRET" \
            --listener "127.0.0.1:${LISTENER_PORT}" &
          TUNNEL_PID=$!
          trap 'kill $TUNNEL_PID' EXIT

          # Give cloudflared a moment to create the listener
          sleep 3

          KNOWN_HOSTS_FILE="$HOME/.ssh/known_hosts"
          mkdir -p "$(dirname "$KNOWN_HOSTS_FILE")"
          touch "$KNOWN_HOSTS_FILE"
          ssh-keyscan -p "${LISTENER_PORT}" 127.0.0.1 >> "$KNOWN_HOSTS_FILE"

          DEPLOY_SCRIPT=$(printf '%s\n' \
            'set -e' \
            'echo "Connected through Cloudflare Tunnel"' \
            'cd "${APP_DIR}"' \
            'if [ ! -d .git ]; then' \
            '  if [ -z "${REPO_URL}" ]; then' \
            '    echo "REPO_URL is not set; cannot bootstrap repository." >&2' \
            '    exit 1' \
            '  fi' \
            '  echo "Repository missing; initializing git repo and configuring origin..."' \
            '  git init' \
            '  git remote add origin "${REPO_URL}"' \
            'else' \
            '  git -C . rev-parse --is-inside-work-tree >/dev/null || {' \
            '    echo "Directory exists but is not a git work tree; aborting." >&2' \
            '    exit 1' \
            '  }' \
            'fi' \
            'git remote set-url origin "${REPO_URL}"' \
            'if [ -n "${ROOT_ENV_B64}" ]; then' \
            '  echo "Updating root .env"' \
            '  echo "${ROOT_ENV_B64}" | base64 -d > .env' \
            'fi' \
            'if [ -n "${UI_ENV_B64}" ]; then' \
            '  echo "Updating ui/.env"' \
            '  mkdir -p ui' \
            '  echo "${UI_ENV_B64}" | base64 -d > ui/.env' \
            'fi' \
            'echo "Pulling latest code..."' \
            'git fetch --all' \
            'git reset --hard origin/main' \
            'echo "Restarting Docker services..."' \
            'COMPOSE_CMD=()' \
            'if command -v docker-compose >/dev/null 2>&1; then' \
            '  COMPOSE_CMD=("docker-compose")' \
            'elif command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then' \
            '  COMPOSE_CMD=("docker" "compose")' \
            'else' \
            '  echo "Neither docker-compose nor docker compose is available." >&2' \
            '  exit 1' \
            'fi' \
            'echo "Cleaning up Docker resources..."' \
            '"${COMPOSE_CMD[@]}" down --remove-orphans' \
            'docker ps -a | grep -E "echomind|poc" | awk "{print \$1}" | xargs -r docker rm -f 2>/dev/null || true' \
            'docker network prune -f 2>/dev/null || true' \
            'sleep 2' \
            'echo "Killing processes on required ports..."' \
            'for PORT in 3031 4000; do' \
            '  echo "Checking port $PORT..."' \
            '  BUSY_PIDS=$(lsof -Pi :$PORT -sTCP:LISTEN -t 2>/dev/null || true)' \
            '  if [ -n "$BUSY_PIDS" ]; then' \
            '    echo "Port $PORT is busy. PIDs: $BUSY_PIDS"' \
            '    lsof -Pi :$PORT -sTCP:LISTEN || true' \
            '    echo "Killing PIDs: $BUSY_PIDS"' \
            '    kill -9 $BUSY_PIDS 2>/dev/null || true' \
            '    sleep 2' \
            '  fi' \
            '  if command -v fuser >/dev/null 2>&1; then' \
            '    fuser -k $PORT/tcp 2>/dev/null || true' \
            '    sleep 1' \
            '  fi' \
            '  REMAINING=$(lsof -Pi :$PORT -sTCP:LISTEN -t 2>/dev/null || true)' \
            '  if [ -n "$REMAINING" ]; then' \
            '    echo "ERROR: Port $PORT still occupied by PIDs: $REMAINING" >&2' \
            '    lsof -Pi :$PORT -sTCP:LISTEN || true' \
            '    exit 1' \
            '  fi' \
            '  echo "Port $PORT is now free"' \
            'done' \
            'sleep 2' \
            'echo "Final port verification before starting containers..."' \
            'for PORT in 3031 4000; do' \
            '  if lsof -Pi :$PORT -sTCP:LISTEN >/dev/null 2>&1; then' \
            '    echo "WARNING: Port $PORT is in use right before docker up!" >&2' \
            '    lsof -Pi :$PORT -sTCP:LISTEN' \
            '    PIDS=$(lsof -Pi :$PORT -sTCP:LISTEN -t 2>/dev/null || true)' \
            '    if [ -n "$PIDS" ]; then' \
            '      echo "Force killing PIDs: $PIDS"' \
            '      kill -9 $PIDS 2>/dev/null || true' \
            '      sleep 2' \
            '    fi' \
            '  else' \
            '    echo "Port $PORT is free"' \
            '  fi' \
            'done' \
            '"${COMPOSE_CMD[@]}" pull || true' \
            '"${COMPOSE_CMD[@]}" build --pull' \
            'echo "Starting containers..."' \
            '"${COMPOSE_CMD[@]}" up -d' \
            'echo "Deployment completed successfully!"')

          ssh -tt -o StrictHostKeyChecking=yes -p "${LISTENER_PORT}" "$SSH_USER@127.0.0.1" \
            APP_DIR="$APP_DIR" \
            ROOT_ENV_B64="$ROOT_ENV_B64" \
            UI_ENV_B64="$UI_ENV_B64" \
            REPO_URL="$REPO_URL" \
            bash -s <<< "$DEPLOY_SCRIPT"
